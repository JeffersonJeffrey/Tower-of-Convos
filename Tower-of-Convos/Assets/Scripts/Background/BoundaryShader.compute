// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Boundary

struct Coral {
    float2 centerPosition;
    float radius;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<Coral> corals;

//Constants 
float e = 2.71828182846;

float hash( float n )
{
    return frac(sin(n)*43758.5453);
}

float noise( float3 x )
{
    // The noise function returns a value in the range -1.0f -> 1.0f

    float3 p = floor(x);
    float3 f = frac(x);

    f       = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + 113.0*p.z;

    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
                    lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
                lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
}

float calcCoralValue(Coral coral, float2 position){
    float a = pow(e, coral.radius);
    float x = coral.centerPosition - position;
    return clamp(pow(e, -x) - a, 0, 1);
}

[numthreads(8,8,1)]
void Boundary (uint3 id : SV_DispatchThreadID)
{

    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
